

opt-FunctionDeclarations

ClassName opt-IdentityFields opt-ClassBlock






User





User( name:String )


lockable User( name:String )


modifiable User( name:String )


modifiable User( name:String ) {

  jsonTemplate = {"name":$name}

  xmlTemplate = <user name="$name"/>

}


UserRestfulEndPoint {

  GET /user/{id} = userRepository.fetchUser( id )    // where fetchUser returns Future<User>
                                                     // supports  'map' to HttpResponse for fine tuning responses

  POST /user = 404

  POST /user = 404 + cookie("a","b") + header("a","b")

}


request.cookies["abc"]
cookies["ABC"]  // array/map/reflection
cookies.ABC     // normal
requestHeaders[]


a.b.c    if a.b is null a.b.c evaluates to null too



lockable AccountDTO( id:String ) {
  created:DTM    = SystemClock.currentDTM()
  nameNbl:String

  constructor( id:String, createdDTM:DTM, nameNbl:String ) {
    super( id )

    this.created = createdDTM
    this.nameNbl = nameNbl
  }

  setter nameNbl( newNameNbl:String )          = this.nameNbl = newNameNbl
  getter nameNbl                      : String = this.nameNbl

  setter nameNbl = this.nameNbl = newNameNbl
  getter nameNbl = this.nameNbl

  json jsonTemplate   = { "id":${id}, "when": ${created}, "name"=${nameNbl} }
  xml  xmlTemplate    = <account id=${id} when=${created} name=${nameNbl}/>
  sql  insertTemplate = insert into ACCOUNT (id,name,created) values(${id},${nameNbl},${created})
  protobuf proto
}

interface AccountService {
  insert( account:Account ) : Void
  fetch( id:String ) : Account


  before insert( account:Account ) = println( "hello" )
  after insert( account:Account )  = {
    println( "bye" )
  }
}

mixin LoggingMixin {

  before * = log( "hello" )
  after  * = log( "bye" )


  private log( msg:String ) = println( msg )

}


use java.lang.Integer with river.lang.RichIntMixin
use river.lang.*
use river.collections.ArrayUtils.*


SCOPE
-----

Idea: avoid typing private by prefixing with _?  Good idea, bad idea?
      how about changing the default. So _X defaults to private but could be declared as 'public _X' if one wanted

_rootLabel
private rootLabel

_ROOT_LABEL
private ROOT_LABEL

_RootLabel

Expressions
------

        // creturn !consume(tokenizer, "(")

        if ( !consume(tokenizer,"(") ) return;



Functions
=========


add(a,b) = a+b
addition = &add


onKeypress( callback(key:Char):Void )

onKeypress( println("key: "+key) )
onKeypress( {println("key: "+key)} )
onKeypress( callback=println("key: "+key) )
onKeypress( callback(k)=println("key: "+k) )
onKeypress( callback(k:Char)=println("key: "+k) )
onKeypress( f(k)=println("key: "+k) )
onKeypress( f(k:Char)=println("key: "+k) )

callback(key) =  println("key: "+key)
onKeypress( &callback )
onKeypress( callback=&callback )




AutoConversions
------------

foo:Colour = "red"


will call   Colour.fromString("red")



or

converter fromStr( str:String ) =



Good to clean up
--------

            if( healthCheck.passed ) {
              monitoringService.debug( "HealthCheck [%s] %s".format(healthCheck.testName,  healthCheck.status) )
            } else {
              monitoringService.fyi( "HealthCheck [%s] %s".format(healthCheck.testName,  healthCheck.status) )
            }


Closure ideas
----------

yes
spinUntilTrue( `ctx.countThreads(threadPrefix) > 0` )

f() = ctx.countThreads(threadPrefix) > 0
f(a,b) = ctx.countThreads(a) > b
f(a,b) = a eq b
f(a,b) : Boolean = a eq b

spinUntilTrue( f )


map( collection:Iterable[A], f(a:A):B ) : Iterable[B]


map( [1,2,3], `a.toString()` )
map( [1,2,3], a.toString() )
map( [1,2,3], f(a)=a.toString() )


[1,2,3].map( e.toString() )
[1,2,3].map( f(e)=e.toString() )

f(e)=e.toString()
[1,2,3].map( f )

No
spinUntilTrue( f(ctx.countThreads(threadPrefix) > 0) )
spinUntilTrue( {ctx.countThreads(threadPrefix) > 0} )
spinUntilTrue( &f )
spinUntilTrue( f )
spinUntilTrue( `f` )
spinUntilTrue( eval f )


f = eval ctx.countThreads(threadPrefix) > 0
f = func ctx.countThreads(threadPrefix) > 0
f := ctx.countThreads(threadPrefix) > 0

f(a,b) := a == b
f(a,b) = `a == b`

